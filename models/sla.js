/**
 * SLA class representing a Service Level Agreement instance.
 *
 * Properties:
 * - id: string - Unique identifier (autogenerated upon creation by route/service)
 * - filepath: string - Path to the SLA file
 * - apiKey: string - API Key assigned to this SLA
 * - templateId: string - The SLA template this SLA uses
 * - validity: boolean - Whether the SLA is currently valid
 * - expiryDate: Date|null - After this date, validity becomes false
 */

class SLA {
  /**
   * Create an SLA instance
   * @param {Object} opts
   * @param {string} opts.id - unique id for the SLA
   * @param {string} opts.filepath - SLA file path
   * @param {string} opts.apiKey - API Key assigned to the SLA
   * @param {string} opts.templateId - SLA template id referenced by this SLA
   * @param {boolean} [opts.validity=true] - initial validity flag
   * @param {string|Date|null} [opts.expiryDate=null] - expiry date; after this date validity becomes false
   */
  constructor(opts = {}) {
    if (!opts || typeof opts !== 'object') {
      throw new TypeError('SLA constructor expects an options object');
    }

    const {
      id,
      filepath,
      apiKey,
      templateId,
      validity = true,
      expiryDate = null
    } = opts;

    if (typeof id !== 'string' || id.length === 0) {
      throw new TypeError('SLA.id must be a non-empty string');
    }
    if (typeof filepath !== 'string' || filepath.length === 0) {
      throw new TypeError('SLA.filepath must be a non-empty string');
    }
    if (typeof apiKey !== 'string' || apiKey.length === 0) {
      throw new TypeError('SLA.apiKey must be a non-empty string');
    }
    if (typeof templateId !== 'string' || templateId.length === 0) {
      throw new TypeError('SLA.templateId must be a non-empty string');
    }
    if (typeof validity !== 'boolean') {
      throw new TypeError('SLA.validity must be a boolean');
    }

    let parsedExpiry = null;
    if (expiryDate != null) {
      parsedExpiry = expiryDate instanceof Date ? expiryDate : new Date(expiryDate);
      if (isNaN(parsedExpiry.getTime())) {
        throw new TypeError('SLA.expiryDate must be a valid Date or date string');
      }
    }

    this.id = id;
    this.filepath = filepath;
    this.apiKey = apiKey;
    this.templateId = templateId;
    this.expiryDate = parsedExpiry; // Date or null

    // validity becomes false after expiry date
    if (this.expiryDate && Date.now() > this.expiryDate.getTime()) {
      this.validity = false;
    } else {
      this.validity = validity;
    }
  }

  /** Returns true if current time is past the expiry date */
  isExpired() {
    return !!(this.expiryDate && Date.now() > this.expiryDate.getTime());
  }

  /** Returns current validity considering expiry date */
  isValid() {
    if (this.isExpired()) return false;
    return this.validity === true;
  }

  /** Serialize for storage */
  toJSON() {
    return {
      id: this.id,
      filepath: this.filepath,
      apiKey: this.apiKey,
      templateId: this.templateId,
      validity: this.isValid(),
      expiryDate: this.expiryDate ? this.expiryDate.toISOString() : null
    };
  }

  /** Hydrate from storage */
  static fromJSON(obj) {
    return new SLA({
      id: obj.id,
      filepath: obj.filepath,
      apiKey: obj.apiKey,
      templateId: obj.templateId,
      validity: typeof obj.validity === 'boolean' ? obj.validity : true,
      expiryDate: obj.expiryDate || null
    });
  }
}

module.exports = SLA;
